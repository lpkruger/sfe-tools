/*
 * Created on Jun 29, 2003
 *
 * To change the template for this generated file go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
package sfe.sfdl;

import java.io.*;
import java.util.*;

/**
 * @author louis
 *
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
public class ESLCFile {

	SFDL esl;
	EDL edl;
	MapList evmap;

	PrintStream ps;

	public ESLCFile(SFDL esl, PrintStream ps) {
		this.ps = ps;
		this.esl = esl;
		this.edl = esl.edl;
		this.evmap = esl.evmap;
	}

	void emitHeader() {

		ps.println("/**");
		ps.println(" * Interface for ESL \"" + esl.eslname + "\"");
		ps.println(" * this file is automatically generated, do not edit");
		ps.println(" */");
		ps.println();
	}

	void emitBoilerplate() {
		ps.println("#include \"" + edl.edlname + ".h\"");
		ps.println();

	}

	void emit() {
		//ps.println("Emitting C code from ESL");

		emitHeader();
		emitBoilerplate();
		ps.println();
		emitVarDecls();
		ps.println();
		emitMatches();
	}

	void emitVarDecls() {
		Iterator it = esl.vars.values().iterator();
		while (it.hasNext()) {
			SFDL.VarDecl var = (SFDL.VarDecl) it.next();
			String initval = "";
			if (var.initialValue != null) {
				if (var.initialValue instanceof String) {
					initval = "=\"" + var.initialValue + "\"";
				}
				else if (var.initialValue instanceof Integer) {
					initval = "=" + var.initialValue;
				} else {
					throw new RuntimeException("Unexpected initial value " + var.initialValue);
				}
			}
			
			ps.println("static " + var.type.getName() + " " + var.name + initval + ";");
		}
	}
	void emitMatches() {
		Iterator it = evmap.keySet().iterator();
		while (it.hasNext()) {
			String evname = (String) it.next();

			emitMatch(evname);
		}

	}

	void emitMatch(String evname) {
		EDL.Event ev = edl.getEvent(evname);
		// emit decl
		StringBuffer sb = new StringBuffer("int eventcall_" + ev.name + "(");
		String comma = "";
		for (int i = 0; i < ev.args.length; ++i) {
			sb.append(comma + "int " + ev.args[i].name + "_type, ");
			if (!ev.args[i].out) sb.append("const ");
			sb.append(ev.args[i].type.getName() + " " + ev.args[i].name);
			comma = ", ";
		}
		sb.append(") {");
		ps.println(sb);

		// emit body
		List evlist = evmap.get(evname);

		Iterator it = evlist.iterator();
		int count = 0;
		while (it.hasNext()) {
			SFDL.Match match = (SFDL.Match) it.next();
			emitTest(ev, match, count++);
		}
		ps.println("  return EDL_ACCEPT;");
		ps.println("}");
		ps.println();
		sb.insert(sb.length() - 3, comma + "int nmatch, " + ev.rettype.getName() + " ret");
		sb.replace(9, 13, "ret");
		sb.replace(0, 3, "void");
		ps.println(sb);
		
		it = evlist.iterator();
		count = 1;
		while (it.hasNext()) {
			SFDL.Match match = (SFDL.Match) it.next();

			if (match.ablock != null) {
				ps.println("  if (nmatch == " + count + ") {");
				ps.println(match.ablock.expr);
				ps.println("  }");
			}
			ps.println();
			++count;
		}
		ps.println("}");
		ps.println();
	}

	void emitTest(EDL.Event ev, SFDL.Match match, int mcount) {
		//assert (ev.argtypes.length == match.argrules.length);

		if (ev.args.length > 0) {

			ps.println("  if(");
			String separ = "";
			for (int i = 0; i < ev.args.length; ++i) {
				// emit test for argument i
				ps.println(separ);
				separ = " && ";
				if (match.argrules[i] instanceof SFDL.TrueRule) {
					ps.println("1");
				} else if (match.argrules[i] instanceof SFDL.FalseRule) {
					ps.println("0");
				} else if (match.argrules[i] instanceof SFDL.TypeRule) {
					// algorithm: find all subtypes of type and emit tests
					
					SFDL.TypeRule trule = (ESL.SFDL) match.argrules[i];
					EDL.Type[] subtypes = edl.getSubTypes(trule.type);
					ps.println(
						"(" + ev.args[i].name
							+ "_type == "
							+ subtypes[0].getTypeConst());
					for (int j=1; j<subtypes.length; ++j ) {
						ps.println("  || " + ev.args[i].name
						+ "_type == "
						+ subtypes[j].getTypeConst());
					}
					ps.println(")");
				} else if (match.argrules[i] instanceof SFDL.RegexRule) {
					String s =
						emitRegexTest(
							(ESL.SFDL) match.argrules[i],
							ev.args[i].name);
					ps.println(s);
				} else {
					if (match.argrules[i] == null) {
						//System.out.println("Unprocessed null rule");
					} else {
						//System.out.println("Unhandled rule type: " + match.argrules[i].getClass().getName());
					}
				}

				// ...
			}

			// test cexprs
			for (int i = 0; i < match.cexprs.length; ++i) {
				ps.println(separ);
				separ = " && ";
				ps.println("(" + match.cexprs[i].expr + ")");
			}

			ps.println("   ) {");
			// TODO: anything else before accept/deny should be done here
			ps.println(
				"     return "
					+ (match.policy == SFDL.POLICY_ALLOW
						? ((mcount+1) + ";")
						: "EDL_DENY;"));
			ps.println("   }");
		}
	}
	String emitRegexTest(SFDL.RegexRule rule, String argname) {
		String quote = rule.isVariable ? "" : "\"";
		String s = "!regex_match(" + quote + rule.regex + quote + "," + argname;

		return s;
	}

}
