/*
 * Created on Apr 23, 2003
 *
 * To change the template for this generated file go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */

package sfe.eslcomp;
import java.io.IOException;
import java.io.PrintStream;
import java.util.Iterator;

//import org.apache.xalan.trace.GenerateEvent;

/**
 * @author lpkruger
 *
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
public class EDLLogFnOutput {
	final static boolean PTRACE=true;
	
	public static void genHeader(PrintStream w) throws IOException {
		w.println("/**");
		w.println(" * Logging functions");
		w.println(" * This file is automatically generated, do not edit!");
		w.println(" */");
		w.println();
		w.println("#include \"edl.h\"");
		w.println("#include \"log.h\"");
		w.println("#define MAX_STRING_LEN 1024");

		// iterate through types

	}

	public void genEvents() {

	}
	public void genEventRoutine() {

	}

	private static String generatePtrTypeFunctions(EDL.Type t, EDL edl) {

		StringBuffer buf = new StringBuffer();
		String pType = t.getPtrType().getPointToType().getName();
		String name = t.getTypeName();
		boolean isChar = (t == edl.typeChar) || (t == edl.typeUChar);

		if (t instanceof EDL.SubType) {
			return "";
		}

		// First, the regular *
		buf.append("void print_" + name + "_ptr(" + pType + " * value) {\n");
		buf.append("\tif (value != NULL) {\n");

		if (isChar) {
			if (PTRACE) buf.append("\t\tvalue = ptrace_alloc_strncpy(value, 1024);\n"); // LINUX
			// FIXME: memory leak
			buf.append("\t\tchar * str = printString(value, strlen(value));\n");
			buf.append("\t\tfprintf(LOG, \" %d %s \", strlen(str), str);\n\t}\n}\n");

		} else {
			if (PTRACE) buf.append("\t\tvalue = ptrace_alloc_memcpy(value, sizeof(*value));\n"); // LINUX
			// FIXME: memory leak
			buf.append("\t\tprint_" + name + "(*value);\n\t}\n}\n");
		}

		if ((t != edl.typeChar)
			&& (t != edl.typeInt)
			&& (t != edl.typeShort)
			&& (t != edl.typeLong)
			&& !(t instanceof EDL.SubType)
			&& !(t instanceof EDL.UnsignedType)) {
			return buf.toString();
		}

		// Next, the ** function
		String format;
		if (t instanceof EDL.UnsignedType) {
			format = ((EDL.UnsignedType) t).getCformat();
		} else {
			format = ((EDL.BasicType) t).getCformat();
		}

		buf.append("void print_" + name + "_pptr(" + pType + " ** value) {\n");
		buf.append("\tchar buf[MAX_STRING_LEN];\n");
		buf.append("\tif (value != NULL) {\n");
		buf.append("\t\tint i=0, n = 0, total = 0;\n");
		buf.append("\t\t" + name + " **ptr;\n");
		buf.append("\t\tmemset(buf, 0, MAX_STRING_LEN);\n");

		buf.append("\t\tfor (ptr = value; (*ptr != NULL) && (total < 1024); ptr++) {\n");
		if (isChar) {

			buf.append(
				"\t\t\t_snprintf(buf+total, MAX_STRING_LEN - total,  \" 0x%08X %d %s %n "
					+ " \", *ptr, strlen(*ptr), *ptr, &n);\n");

		} else {
			buf.append(
				"\t\t\t_snprintf(buf+total, MAX_STRING_LEN - total,  \" 0x%08X " + format + " %n " + " \", *ptr, **ptr, &n);\n");
		}
		buf.append("\t\t\ttotal += n;\n");
		buf.append("\t\t\ti++;\n\t\t}\n");
		buf.append("\t\tif (i > 0) {\n");
		buf.append("\t\t\tfprintf(LOG, \" %d %s \", i, buf);\n");
		buf.append("\t\t} else {\n");
		buf.append("\t\t\tfprintf(LOG, \" 0 \");\n");
		buf.append("\t\t}\n\t}\n}\n");

		return buf.toString();

	}

	private static String generateUnsignedTypeFunctions(EDL.UnsignedType ut) {
		StringBuffer buf = new StringBuffer();
		String name = ut.getName();
		EDL.Type bt = ut.realType;

		buf.append("void print_" + name + "(" + name + " value) {\n");

		buf.append("\tfprintf(LOG, \" ");

		buf.append(ut.getCformat() + " \"");

		buf.append(", value);\n");
		buf.append("}\n");

		return buf.toString();
	}

	private static String generateBasicTypeFunctions(EDL.BasicType bt) {

		StringBuffer buf = new StringBuffer();
		String name = bt.getName();

		if (bt == bt.getEDL().typeMap) {
			return "";
		}
		buf.append("void print_" + name + "(" + name + " value) {\n");
		buf.append("\tfprintf(LOG, \" ");

		if (bt == bt.getEDL().typeString) {
			// we assume null terminated string
			buf.append(" %d %s \", strlen(value) ");
		} else {
			buf.append(bt.getCformat() + " \"");
		}

		buf.append(", value);\n");
		buf.append("}\n");

		return buf.toString();
	}

	private static String generateStructTypeFunctions(EDL.StructType st) {

		StringBuffer buf = new StringBuffer();
		String name = st.getName();
		// We don't want to have the "struct" keyword
		String typeName = st.getTypeName();
		buf.append("void print_" + typeName + "(" + name + " value) {\n");
		buf.append("\tfprintf(LOG, \"{\");\n");
		for (int i = 0; i < st.ftypes.length; ++i) {

			String field = st.fnames[i];
			String fieldType = st.ftypes[i].getTypeName();

			if (st.ftypes[i] instanceof EDL.PtrType) {
				EDL.PtrType pT = (EDL.PtrType) st.ftypes[i];

				if (pT.getBaseType() instanceof EDL.SubType) {
					fieldType = ((EDL.SubType) pT.getBaseType()).getRealType().getName();
				}
				String pDepth = pT.getDepth("ptr", "p");
				buf.append("\tfprintf(LOG, \" 0x%08X \", value." + field + ");\n");

				buf.append("\tprint_" + fieldType + "_" + pDepth + "(value." + field + ");\n");

			} else if (st.ftypes[i] instanceof EDL.DefinateArrayType) {
				int len = ((EDL.DefinateArrayType) st.ftypes[i]).getArraySize();
				buf.append("\tprint_" + fieldType + "_array(value." + field + ", " + len + ");\n");
			} else if (st.ftypes[i] instanceof EDL.IndefinateArrayType) {
				String len = ((EDL.IndefinateArrayType) st.ftypes[i]).len;
				buf.append("\tprint_" + fieldType + "_array(value." + field + ", " + len + ");\n");
			} else if (st.ftypes[i] instanceof EDL.SubType) {
				fieldType = ((EDL.SubType) st.ftypes[i]).getRealType().getName();
				buf.append("\tprint_" + fieldType + "(value." + field + ");\n");
			} else {
				buf.append("\tprint_" + fieldType + "(value." + field + ");\n");
			}
		}
		buf.append("\tfprintf(LOG, \"}\");\n");
		buf.append("}\n");
		return buf.toString();
	}

	private static String generateSubTypeFunctions(EDL.SubType st) {
		StringBuffer buf = new StringBuffer();
		String name = st.getName();
		EDL.Type bt = st.getRealType();
		buf.append("void print_" + name + "(" + name + " value) {\n");
		buf.append("\tprint_" + bt.getName() + "(value);\n");
		buf.append("}\n");
		return buf.toString();
	}

	private static String generateArrayFunctions(EDL.Type t, EDL edl) {

		String buf = "";
		if (t == edl.typeChar) {

		}

		return buf;
	} /**
						 * This method calls a set of gen* methods to generate various
						 * print functions for different data types 
						 * @param edl
						 * @param w
						 * @throws IOException
						 */
	private static void generatePrintFunctions(EDL edl, PrintStream w) throws IOException {

		Iterator it = edl.namedTypes.values().iterator();
		// First, reset the emitted flag
		edl.resetEmitted();
		while (it.hasNext()) {
			StringBuffer buf = new StringBuffer();
			EDL.Type t = (EDL.Type) it.next();
			if (t.emitted) {
				continue;
			}

			if (t instanceof EDL.BasicType) {
				buf.append(generateBasicTypeFunctions((EDL.BasicType) t));
			} else if (t instanceof EDL.UnsignedType) {
				buf.append(generateUnsignedTypeFunctions((EDL.UnsignedType) t));
			} else if (t instanceof EDL.PtrType) {
				//generatePrtTypeFunctions(t, edl);
			} else if (t instanceof EDL.StructType) {
				buf.append(generateStructTypeFunctions((EDL.StructType) t));
			} else if (t instanceof EDL.UnionType) {
				// TODO: Handle Union Types
				//generateUnionTypeFunctions(t, w);
			} else if (t instanceof EDL.ArrayType) { //generateArrayTypeFunctions();
			} else if (t instanceof EDL.SubType) {
				buf.append(generateSubTypeFunctions((EDL.SubType) t));
			} else {
				t.emitted = true;
				return;
			} //	Emitted
			t.emitted = true;
			// We also need to generate point to type
			if (buf.length() > 0) {
				if (t.getPtrType() != null) {
					buf.append(generatePtrTypeFunctions(t, edl));
				}
			}

			w.print(buf);
			//	Next, generate the array printing functions
			String arrays = generateArrayFunctions(t, edl);
		}

	}

	private static void printArrays(EDL.ArrayType type, String arg, EDL.Event e, PrintStream w) {
		EDL.Type real = type.eltype;
		StringBuffer specialCalls = new StringBuffer();
		String len = null;
		int index = 0, i;
		if (type instanceof EDL.DefinateArrayType) {
			len = Integer.toString(((EDL.DefinateArrayType) type).len);
		} else {
			for (index = 0; index < e.args.length; index++) {
				if (e.args[index] == ((EDL.IndefinateArrayType) type).lendef) {
					break;
				}
			} // The length parameter may be a pointer type
			if (e.args[index].type instanceof EDL.PtrType) {
				len = "*((int*) *arg" + index + ")";
			} else {
				len = "(int) *arg" + index;
			}
		}

		if ((real == type.getEDL().typeChar) || (real == type.getEDL().typeUChar)) {
			specialCalls.append("\n\t{\n");			if (PTRACE) specialCalls.append("\t\tchar * tmp = ptrace_alloc_memcpy((char *)*" + arg + "," + len + ");\n"); // LINUX
			specialCalls.append("\t\tchar * str = printString(tmp," + len + ");\n");
			if (PTRACE) specialCalls.append("\t\tfree(tmp);\n");  // LINUX
			specialCalls.append("\t\tfprintf(LOG, \" %d %s \", strlen(str), str);\n\t}\n");
		} else { // More cases
		}
		w.print(specialCalls);
	} /**
						 * This method prints out the arguments based on the type. 
						 * @param argType
						 * @param w
						 * @throws IOException
						 */
	private static void printArgument(EDL.Type argType, String arg, EDL.Event e, PrintStream w) throws IOException {

		int type = argType.typeConst;
		String mark = type + "-0";
		String pDepth = null;
		EDL.Type realType;

		// First, find out the depth
		if (argType instanceof EDL.PtrType) {
			EDL.PtrType pt = (EDL.PtrType) argType;
			pDepth = pt.getDepth("ptr", "p");
			argType = pt.getBaseType();
			if (argType instanceof EDL.SubType) {
				argType = ((EDL.SubType) argType).getRealType();
			}
		}

		// Next, see if it's a subtype

		String typeName = argType.getTypeName();
		// If it's a pointer, first, print out the address
		if (pDepth != null) {
			// First the pointer value
			w.print("\tfprintf(LOG, \" 0x%08X \", *" + arg + ");\n");
			// Then the actual pointer data
			w.print("\tprint_" + typeName + "_" + pDepth + "( (" + argType.getName() + "*)*" + arg + ");\n");
		} else { // Array needs special attention
			if (argType instanceof EDL.ArrayType) {
				// deal with array type
				printArrays((EDL.ArrayType) argType, arg, e, w);
			} else {
				w.print("\tprint_" + typeName + "( (" + argType.getName() + ")*" + arg + ");\n");
			}
		}

	}

	public static void genLogRoutines(EDL edl, PrintStream w) throws IOException {
		genHeader(w);
		// First, generate the auxiliary functions
		generatePrintFunctions(edl, w);
		// Next, generate each logging function		
		Iterator it = edl.eventList.iterator();
		while (it.hasNext()) {
			int i;
			EDL.Event e = (EDL.Event) it.next();
			w.print("void log_" + e.name + "( ");
			int length = e.args.length;
			for (i = 0; i < length; i++) {
				w.print("DWORD *arg" + Integer.toString(i));
				w.print(", ");
			} // Now output the IP
			w.print("DWORD * rc, int ip) {\n");
			w.print("\tfprintf(LOG, \"0x%08X: %d %d %d " + e.name + "(\", ");
			w.print("ip, CALLID++, _getpid(), GetCurrentThreadId());\n");
			// Determines the argument type & print out
			//String comma1 = "";
			//String comma2 = "\tfprintf(LOG, \",\");";
			for (i = 0; i < length; i++) {
				//	w.print(comma1);
				printArgument(e.args[i].type, "arg" + Integer.toString(i), e, w);
				//	comma1 = comma2;
			}

			w.print("\tfprintf(LOG, \") = \");\n");
			// Now check the return type
			printArgument(e.rettype, "rc", e, w);
			w.print("\tfprintf(LOG, \"\\n\");");
			w.print("\n}\n");
		} //log_bind(DWORD *arg1, DWORD *arg2, DWORD *arg3, DWORD rc, DWORD ip) {
		//  fprintf(LOG, "%x: %d %d %d bind (%x, %x, %x) = %x\n",
		//	ip, CALLID++, _getpid(), GetCurrentThreadId(),
		//	*arg1, *arg2, *arg3, rc);
	}

}
