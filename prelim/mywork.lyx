#LyX 1.4.4 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Section
Techniques for Protocol Optimization
\end_layout

\begin_layout Standard
There are various ways to approach the problem of designing optimized secure
 function evaluation protocols.
 My prior work has focused on three general methodologies.
 From most specific to least specific, three approaches I have looked at
 are algorithm specific, algorithm 
\emph on
class
\emph default
 specific, and a general approach that is applicable to all computable functions.
 The trade-off between these different approaches is a balance between performan
ce and general applicability.
 This trade-off has an analogy in traditional programming: General code
 optimizations, such as loop unrolling or strength reduction can make all
 code faster to a limited degree (although this is not guarenteed), but
 tuning a specific algorithm by hand often yields superior results.
 Algorithm class methods fall in between, with ideas that apply to more
 than one related algorithm, but not to all algorithms in general.
\end_layout

\begin_layout Subsection
General: Protocol Optimization using Ordered Binary Decision Diagrams
\end_layout

\begin_layout Standard

\emph on
Ordered Binary Decision Diagrams
\emph default
 (OBDDS) are a graph-based representation of Boolean functions that have
 been used in a variety of applications in computer-aided design, including
 symbolic model checking (a technique for verifying designs), verification
 of combinational logic, and verification of finite-state concurrent systems
 
\begin_inset LatexCommand \cite{Bryant:BDD,Clarke:book}

\end_inset

.
 OBDDs can be readily extended to represent functions with arbitrary domains
 and ranges.
\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand \cite{kruger06}

\end_inset

, I present an SFE algorithm that directly uses an OBDD representation of
 the function 
\begin_inset Formula $f$
\end_inset

 to be jointly computed.
 The advantage of using an OBDD representation over the gate-representation
 is that OBDDs are more succinct for certain classes of functions than the
 gate representation, including most linear functions.
 For example, among other functions, the results show the OBDD representation
 is more efficient than the Boolean gate representation for 8-bit AND, 8-bit
 addition, and the millionaire's and billionaire's problems
\begin_inset LatexCommand \cite{Yao:86}

\end_inset

 For other functions, such as multiplication, the OBDD can be far worse
 than the Boolean gate representation.
\end_layout

\begin_layout Standard
The conclusion is that SFE optimization using OBDDs are a technique that
 is applicable to any function.
 
\end_layout

\begin_layout Subsection
Algorithm Class Specific: Protocol Optimization of Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula ${\cal P}(x,y)$
\end_inset

 be a problem with two inputs 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, e.g., for the problem of computing edit-distance between two strings the
 inputs 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are the strings.
 Typically, a dynamic-programming algorithm 
\begin_inset Formula ${\cal A}_{{\cal P}}$
\end_inset

 for problem 
\begin_inset Formula ${\cal P}$
\end_inset

 has the following components:
\end_layout

\begin_layout Itemize
A set 
\begin_inset Formula $S$
\end_inset

 of sub-problems and a dependency relation 
\begin_inset Formula $R\subseteq S\times S$
\end_inset

 between the sub-problems.
 Intuitively, 
\begin_inset Formula $(s,s')\in R$
\end_inset

 means that the sub-problem 
\begin_inset Formula $s'$
\end_inset

 depends on the sub-problem 
\begin_inset Formula $s$
\end_inset

.
 If there is a dependency between 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, we write it as 
\begin_inset Formula $s\rightarrow s'$
\end_inset

.
 In the case of the problem of computing edit-distance between two strings
 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 of length 
\begin_inset Formula $n$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

, the set of sub-problems is 
\begin_inset Formula $[0,\cdots,n]\times[0,\cdots,m]$
\end_inset

.
 For all sub-problems 
\begin_inset Formula $(i,j)$
\end_inset

 such that 
\begin_inset Formula $i\not=0$
\end_inset

 and 
\begin_inset Formula $j\not=0$
\end_inset

, we have the following dependencies: 
\begin_inset Formula $(i-1,j)\rightarrow(i,j)$
\end_inset

, 
\begin_inset Formula $(i,j-1)\rightarrow(i,j)$
\end_inset

, and 
\begin_inset Formula $(i-1,j-1)\rightarrow(i,j)$
\end_inset

.
 The 
\shape italic
base sub-problems
\shape default
 are 
\begin_inset Formula $s\in S$
\end_inset

 such that they have no dependencies.
 For the edit-distance problem, the base sub-problems are: 
\begin_inset Formula \[
\begin{array}{l}
\{(i,0)\;\mid\;0\leq i\leq n\}\\
\{(0,j)\;\mid\;0\leq j\leq m\}\end{array}\]

\end_inset

 We also assume that there is a unique root sub-problem 
\begin_inset Formula ${\it root}\in S$
\end_inset

 such that there does not exist a sub-problem that depends on 
\begin_inset Formula ${\it root}$
\end_inset

.
 For the edit-distance problem the unique root sub-problem is 
\begin_inset Formula $(n,m)$
\end_inset

.
\end_layout

\begin_layout Itemize
Each sub-problem 
\begin_inset Formula $s$
\end_inset

 is assigned a value 
\begin_inset Formula ${\it val}(s)$
\end_inset

.
 The goal is to compute 
\begin_inset Formula ${\it val}({\it root})$
\end_inset

.
 The function 
\begin_inset Formula ${\it val}$
\end_inset

 from 
\begin_inset Formula $S$
\end_inset

 to 
\begin_inset Formula $\Re$
\end_inset

 assigns values to sub-problems, such that it satisfies the following properties
:
\end_layout

\begin_deeper
\begin_layout Itemize
For all the base sub-problems 
\begin_inset Formula $s\in S$
\end_inset

, 
\begin_inset Formula ${\it val}(s)$
\end_inset

 is defined.
\end_layout

\begin_layout Itemize
Let 
\begin_inset Formula $s\in S$
\end_inset

 be a non-base sub-problem.
 Define 
\begin_inset Formula ${\it pred}(s)$
\end_inset

 as all the predecessors of 
\begin_inset Formula $s$
\end_inset

, i.e.
 the set 
\begin_inset Formula ${\it pred}(s)$
\end_inset

 is defined as 
\begin_inset Formula $\{ s'\;\mid\; s'\rightarrow s\}$
\end_inset

.
 Assume that 
\begin_inset Formula ${\it pred}(s)$
\end_inset

 is equal to 
\begin_inset Formula $\{ s_{1},\cdots,s_{k}\}$
\end_inset

.
 There is a recursive function 
\begin_inset Formula $f$
\end_inset

 defining 
\begin_inset Formula ${\it val}(s)$
\end_inset

 in terms of 
\begin_inset Formula ${\it val}(s_{1}),{\it val}(s_{2}),\cdots,{\it val}(s_{k})$
\end_inset

, 
\begin_inset Formula $s(x)$
\end_inset

, and 
\begin_inset Formula $s(y)$
\end_inset

, where 
\begin_inset Formula $s(x)$
\end_inset

 and 
\begin_inset Formula $s(y)$
\end_inset

 are parts of the input 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 that are relevant to the sub-problem 
\begin_inset Formula $s$
\end_inset

.
 In case of the edit-distance problem 
\begin_inset Formula ${\it val}((i,j))$
\end_inset

 is equal to 
\begin_inset Formula $D(i,j)$
\end_inset

.
 The value for the base and non-base sub problems for the edit-distance
 problems was defined in equations\InsetSpace ~

\begin_inset LatexCommand \ref{eqn:base-case}

\end_inset

 and\InsetSpace ~

\begin_inset LatexCommand \ref{eqn:recursive}

\end_inset

 in Section\InsetSpace ~

\begin_inset LatexCommand \ref{sec:edit-distance}

\end_inset

.
\end_layout

\end_deeper
\begin_layout Subsection
Algorithm Specific: Protocol Optimization of K-Means Clustering
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $k$
\end_inset

-means algorithm is a common clustering technique in data mining.
 Assume that we are given 
\begin_inset Formula $n$
\end_inset

 samples 
\begin_inset Formula $x_{1},\cdots,x_{n}$
\end_inset

, where each sample is a 
\begin_inset Formula $m$
\end_inset

-dimensional vector of real numbers.
 The number of clusters is 
\begin_inset Formula $c$
\end_inset

.
 The algorithm maintains 
\begin_inset Formula $c$
\end_inset

 means 
\begin_inset Formula $\mu_{1},\cdots,\mu_{c}$
\end_inset

.
 Initially, assume that the means are assigned arbitrary values.
 A sample 
\begin_inset Formula $x_{i}$
\end_inset

 is deemed to be in the cluster 
\begin_inset Formula $j$
\end_inset

 if it is closest to the mean 
\begin_inset Formula $\mu_{j}$
\end_inset

, where mean of a cluster 
\begin_inset Formula $\{ x'_{1},\cdots,x'_{r}\}$
\end_inset

 is 
\begin_inset Formula $\frac{x'_{1}+\cdots,x'_{r}}{r}$
\end_inset

.
 Distance between two 
\begin_inset Formula $m$
\end_inset

-dimensional vectors 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 is given by 
\begin_inset Formula $\sum_{j=1}^{m}(x[j]-y[j])^{2}$
\end_inset

, where 
\begin_inset Formula $x[j]$
\end_inset

 is the 
\begin_inset Formula $j$
\end_inset

-th element of the vector 
\begin_inset Formula $x$
\end_inset

.
 Other distance metrics\InsetSpace ~

\begin_inset LatexCommand \cite[Chapter 10]{pattern-classification}

\end_inset

, such as scatter metrics, can be used instead of the distance metric mentioned
 above.
 Each iteration of the 
\begin_inset Formula $k$
\end_inset

-means algorithms recomputes the means and reclassifies the samples.
 The algorithm terminates when it detects 
\begin_inset Quotes eld
\end_inset

no change
\begin_inset Quotes erd
\end_inset

 in the means.
 The precise definition of 
\begin_inset Quotes eld
\end_inset

no change
\begin_inset Quotes erd
\end_inset

 depends on the specific metric being used.
 
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Standard
\begin_inset LatexCommand \bibtex[plain]{somesh}

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
