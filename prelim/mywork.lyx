#LyX 1.4.4 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\spacing single
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Section
Techniques for Protocol Optimization
\end_layout

\begin_layout Standard
There are various ways to approach the problem of designing optimized secure
 function evaluation protocols.
 My prior work has focused on three general methodologies.
 From most specific to least specific, three approaches I have looked at
 are algorithm specific, algorithm 
\emph on
class
\emph default
 specific, and a general approach that is applicable to all computable functions.
 The trade-off between these different approaches is a balance between performan
ce and general applicability.
 This trade-off has an analogy in traditional programming: General code
 optimizations, such as loop unrolling or strength reduction can make all
 code faster to a limited degree (although this is not guarenteed), but
 tuning a specific algorithm by hand often yields superior results.
 Algorithm class methods fall in between, with ideas that apply to more
 than one related algorithm, but not to all algorithms in general.
\end_layout

\begin_layout Subsection
General: Protocol Optimization using Ordered Binary Decision Diagrams
\end_layout

\begin_layout Standard

\emph on
Ordered Binary Decision Diagrams
\emph default
 (OBDDS) are a graph-based representation of Boolean functions that have
 been used in a variety of applications in computer-aided design, including
 symbolic model checking (a technique for verifying designs), verification
 of combinational logic, and verification of finite-state concurrent systems
 
\begin_inset LatexCommand \cite{Bryant:BDD,Clarke:book}

\end_inset

.
 OBDDs can be readily extended to represent functions with arbitrary domains
 and ranges.
 An OBDD is similar to a decision tree, in that evaluation is performed
 from a head node to leaves.
 However, an OBDD is not ordinarily a tree, because internal nodes with
 identical structure are shared.
 Given a function 
\begin_inset Formula $f(x_{1},x_{2},\cdots,x_{n})$
\end_inset

, the OBDD for that function will have 
\begin_inset Formula $n$
\end_inset

 levels, with the 
\begin_inset Formula $i^{th}$
\end_inset

 level corresponding to 
\begin_inset Formula $x_{l_{i}}$
\end_inset

, where 
\begin_inset Formula $(l_{1},\cdots,l_{n})$
\end_inset

 is a permutation of 
\begin_inset Formula $(1,\cdots,n)$
\end_inset

.
 There is a unique canonical decision tree corresponding to any function
 with respect to a given ordering 
\begin_inset Formula $(l_{1},\cdots,l_{n})$
\end_inset

.
 An example of an OBDD to compute the function 
\begin_inset Formula $F(x)=\# x1\# x3>\# x2\# x4$
\end_inset

 (two-bit millionaires problem) is shown in 
\begin_inset LatexCommand \ref{fig:OBDD-example}

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename obdd1.png
	lyxscale 5
	scale 40
	rotateAngle 270

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:OBDD-example}

\end_inset

OBDD for two-bit millionaires problem
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In 
\begin_inset LatexCommand \cite{kruger06}

\end_inset

, I presented an SFE protocol that directly uses an OBDD representation
 of the function 
\begin_inset Formula $f$
\end_inset

 to be jointly computed.
 The advantage of using an OBDD representation over the Boolean gate-representat
ion is that OBDDs are more succinct for certain classes of functions than
 the Boolean gate representation, including most linear functions.
 For example, the OBDD representation is more efficient than the Boolean
 gate representation for 8-bit AND, 8-bit addition, and the millionaire's
 and billionaire's problems
\begin_inset LatexCommand \cite{Yao:86}

\end_inset

 OBDDs are not a universal solution, however, for other functions, such
 as multiplication, the OBDD can be far worse than the Boolean gate representati
on.
 For the classes of functions in which the OBDD representation is efficient,
 the paper shows that the protocol described next can perform 2 to 4 times
 better than the classical Yao protocol.
\end_layout

\begin_layout Standard
The protocol is loosely designed in a similar fashion as Yao's protocol
 
\begin_inset LatexCommand \cite{Yao86}

\end_inset

.
 We present two variations of the protocol.
 The steps of the protocol 1 are shown in 
\begin_inset LatexCommand \ref{fig:OBDD-overview}

\end_inset

, using the example millionaire's problem pictured above.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename obdd_proto_overview.png
	lyxscale 5
	scale 40
	rotateAngle 270

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:OBDD-overview}

\end_inset

OBDD secure evaluation protocol
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Include \input{bdd-proto.lyx}
preview false

\end_inset


\end_layout

\begin_layout Standard
Protocol 2 is nearly identical to protocol 1, except that Alice first reduces
 the number of nodes to be sent to Bob using an operation called 
\emph on
restriction
\emph default
, which is a partial evaluation applied to OBDDs.
 Restriction is defined as follows.
 
\end_layout

\begin_layout Standard
Given an 
\begin_inset Formula $n$
\end_inset

 variable Boolean function 
\begin_inset Formula $f(x_{1},x_{2},\cdots,x_{n})$
\end_inset

 and a Boolean value 
\begin_inset Formula $b$
\end_inset

, the restriction 
\begin_inset Formula $f\mid_{x_{i}\leftarrow b}$
\end_inset

 is a Boolean function of 
\begin_inset Formula $n-1$
\end_inset

 variables 
\begin_inset Formula $x_{1},\cdots,x_{i-1},x_{i+1},\cdots,x_{n}$
\end_inset

.
 
\begin_inset Formula $f\mid_{x_{i}\leftarrow b}(x_{1},\cdots,x_{i-1},x_{i+1},\cdots,x_{n})$
\end_inset

 is equal to 
\begin_inset Formula $f(x_{1},\cdots,x_{i-1},b,x_{i+1},\cdots,x_{n})$
\end_inset

.
 Essentially 
\begin_inset Formula $f\mid_{x_{i}\leftarrow b}$
\end_inset

 is the function obtained by substituting the value 
\begin_inset Formula $b$
\end_inset

 for the variable 
\begin_inset Formula $x_{i}$
\end_inset

 in the function 
\begin_inset Formula $f$
\end_inset

.
 The restriction operation can be performed over multiple variables by restricti
ng each variable independently, e.g., 
\begin_inset Formula $f\mid_{x_{i}\leftarrow b,x_{j}\leftarrow b'}=(f\mid_{x_{i}\leftarrow b})\mid_{x_{j}\leftarrow b'}$
\end_inset

.
 The order in which the variables are restricted is unimportant.
\end_layout

\begin_layout Standard
\align left
For protocol 2, both parties' inputs include the 
\begin_inset Formula $OBDD(f)$
\end_inset

 for the Boolean function 
\begin_inset Formula $f(x_{1},x_{2},\cdots,x_{n})$
\end_inset

 with the ordering 
\begin_inset Formula $x_{1}<x_{2}<\cdots<x_{n}$
\end_inset

.
 Furthermore, Alice holds the inputs for the variables in the set 
\begin_inset Formula $X_{A}$
\end_inset

 and Bob holds the inputs for the variables in the set 
\begin_inset Formula $X_{B}\;=\;\{ x_{1},\cdots,x_{n}\}-X_{A}$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
Alice performs the following steps: 
\end_layout

\begin_deeper
\begin_layout Enumerate
Alice computes the OBDD 
\begin_inset Formula ${\cal O}_{A}$
\end_inset

 as the restriction of her inputs on the function 
\begin_inset Formula $f\mid_{X_{A}}$
\end_inset

.
 
\end_layout

\begin_layout Enumerate
Alice encrypts the 
\begin_inset Formula $O_{A}$
\end_inset

 and sends it to Bob.
 This step is exactly the same as in for Protocol 1.
 Alice also sends the secret corresponding to the root of the OBDD 
\begin_inset Formula ${\cal O}_{A}$
\end_inset

.
\end_layout

\end_deeper
\begin_layout Enumerate
The computation for Bob is exactly the same as that for Protocol 1.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Present OBDDs, with pictures and running example
\end_layout

\begin_layout Standard
Present protocol
\end_layout

\begin_layout Standard
Use pictures from CCS talk.
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Class of Algorithm Specific: Protocol Optimization of Dynamic Programming
\end_layout

\begin_layout Standard
Let 
\begin_inset Formula ${\cal P}(x,y)$
\end_inset

 be a problem with two inputs 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

, e.g., for the problem of computing edit-distance between two strings the
 inputs 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 are the strings.
 Typically, a dynamic-programming algorithm 
\begin_inset Formula ${\cal A}_{{\cal P}}$
\end_inset

 for problem 
\begin_inset Formula ${\cal P}$
\end_inset

 has the following components:
\end_layout

\begin_layout Itemize
A set 
\begin_inset Formula $S$
\end_inset

 of sub-problems and a dependency relation 
\begin_inset Formula $R\subseteq S\times S$
\end_inset

 between the sub-problems.
 Intuitively, 
\begin_inset Formula $(s,s')\in R$
\end_inset

 means that the sub-problem 
\begin_inset Formula $s'$
\end_inset

 depends on the sub-problem 
\begin_inset Formula $s$
\end_inset

.
 If there is a dependency between 
\begin_inset Formula $s$
\end_inset

 and 
\begin_inset Formula $s'$
\end_inset

, we write it as 
\begin_inset Formula $s\rightarrow s'$
\end_inset

.
 In the case of the problem of computing edit-distance between two strings
 
\begin_inset Formula $\alpha$
\end_inset

 and 
\begin_inset Formula $\beta$
\end_inset

 of length 
\begin_inset Formula $n$
\end_inset

 and 
\begin_inset Formula $m$
\end_inset

, the set of sub-problems is 
\begin_inset Formula $[0,\cdots,n]\times[0,\cdots,m]$
\end_inset

.
 For all sub-problems 
\begin_inset Formula $(i,j)$
\end_inset

 such that 
\begin_inset Formula $i\not=0$
\end_inset

 and 
\begin_inset Formula $j\not=0$
\end_inset

, we have the following dependencies: 
\begin_inset Formula $(i-1,j)\rightarrow(i,j)$
\end_inset

, 
\begin_inset Formula $(i,j-1)\rightarrow(i,j)$
\end_inset

, and 
\begin_inset Formula $(i-1,j-1)\rightarrow(i,j)$
\end_inset

.
 The 
\shape italic
base sub-problems
\shape default
 are 
\begin_inset Formula $s\in S$
\end_inset

 such that they have no dependencies.
 For the edit-distance problem, the base sub-problems are: 
\begin_inset Formula \[
\begin{array}{l}
\{(i,0)\;\mid\;0\leq i\leq n\}\\
\{(0,j)\;\mid\;0\leq j\leq m\}\end{array}\]

\end_inset

 We also assume that there is a unique root sub-problem 
\begin_inset Formula ${\it root}\in S$
\end_inset

 such that there does not exist a sub-problem that depends on 
\begin_inset Formula ${\it root}$
\end_inset

.
 For the edit-distance problem the unique root sub-problem is 
\begin_inset Formula $(n,m)$
\end_inset

.
\end_layout

\begin_layout Itemize
Each sub-problem 
\begin_inset Formula $s$
\end_inset

 is assigned a value 
\begin_inset Formula ${\it val}(s)$
\end_inset

.
 The goal is to compute 
\begin_inset Formula ${\it val}({\it root})$
\end_inset

.
 The function 
\begin_inset Formula ${\it val}$
\end_inset

 from 
\begin_inset Formula $S$
\end_inset

 to 
\begin_inset Formula $\Re$
\end_inset

 assigns values to sub-problems, such that it satisfies the following properties
:
\end_layout

\begin_deeper
\begin_layout Itemize
For all the base sub-problems 
\begin_inset Formula $s\in S$
\end_inset

, 
\begin_inset Formula ${\it val}(s)$
\end_inset

 is defined.
\end_layout

\begin_layout Itemize
Let 
\begin_inset Formula $s\in S$
\end_inset

 be a non-base sub-problem.
 Define 
\begin_inset Formula ${\it pred}(s)$
\end_inset

 as all the predecessors of 
\begin_inset Formula $s$
\end_inset

, i.e.
 the set 
\begin_inset Formula ${\it pred}(s)$
\end_inset

 is defined as 
\begin_inset Formula $\{ s'\;\mid\; s'\rightarrow s\}$
\end_inset

.
 Assume that 
\begin_inset Formula ${\it pred}(s)$
\end_inset

 is equal to 
\begin_inset Formula $\{ s_{1},\cdots,s_{k}\}$
\end_inset

.
 There is a recursive function 
\begin_inset Formula $f$
\end_inset

 defining 
\begin_inset Formula ${\it val}(s)$
\end_inset

 in terms of 
\begin_inset Formula ${\it val}(s_{1}),{\it val}(s_{2}),\cdots,{\it val}(s_{k})$
\end_inset

, 
\begin_inset Formula $s(x)$
\end_inset

, and 
\begin_inset Formula $s(y)$
\end_inset

, where 
\begin_inset Formula $s(x)$
\end_inset

 and 
\begin_inset Formula $s(y)$
\end_inset

 are parts of the input 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 that are relevant to the sub-problem 
\begin_inset Formula $s$
\end_inset

.
 In case of the edit-distance problem 
\begin_inset Formula ${\it val}((i,j))$
\end_inset

 is equal to 
\begin_inset Formula $D(i,j)$
\end_inset

.
 The value for the base and non-base sub problems for the edit-distance
 problems was defined in equations\InsetSpace ~

\begin_inset LatexCommand \ref{eqn:base-case}

\end_inset

 and\InsetSpace ~

\begin_inset LatexCommand \ref{eqn:recursive}

\end_inset

 in Section\InsetSpace ~

\begin_inset LatexCommand \ref{sec:edit-distance}

\end_inset

.
\end_layout

\end_deeper
\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Present protocols
\end_layout

\begin_layout Standard
Picture of grid
\end_layout

\begin_layout Standard
Discuss design rationale
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename grid.eps
	lyxscale 50
	scale 30
	clip

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:DYN-grid}

\end_inset

Example grid
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Standard
NOTE: Expand this section
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Algorithm Specific: Protocol Optimization of K-Means Clustering
\end_layout

\begin_layout Standard
The 
\begin_inset Formula $k$
\end_inset

-means algorithm is a common clustering technique in data mining.
 Suppose that we are given 
\begin_inset Formula $n$
\end_inset

 samples 
\begin_inset Formula $x_{1},\cdots,x_{n}$
\end_inset

, where each sample is a 
\begin_inset Formula $m$
\end_inset

-dimensional vector of real numbers.
 The problem is to assign the samples to 
\begin_inset Formula $c$
\end_inset

 clusters such a manner that similar points are grouped together.
 Similarity is defined using a distance metric.
 The standard clusteringt algorithm maintains 
\begin_inset Formula $c$
\end_inset

 means 
\begin_inset Formula $\mu_{1},\cdots,\mu_{c}$
\end_inset

.
 Initially, assume that the means are assigned arbitrary values.
 A sample 
\begin_inset Formula $x_{i}$
\end_inset

 is deemed to be in the cluster 
\begin_inset Formula $j$
\end_inset

 if it is closest to the mean 
\begin_inset Formula $\mu_{j}$
\end_inset

, where mean of a cluster 
\begin_inset Formula $\{ x'_{1},\cdots,x'_{r}\}$
\end_inset

 is 
\begin_inset Formula $\frac{x'_{1}+\cdots,x'_{r}}{r}$
\end_inset

.
 In a Euclidean space, the distance between two 
\begin_inset Formula $m$
\end_inset

-dimensional vectors 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 is 
\begin_inset Formula $\sum_{j=1}^{m}(x[j]-y[j])^{2}$
\end_inset

, where 
\begin_inset Formula $x[j]$
\end_inset

 is the 
\begin_inset Formula $j$
\end_inset

-th element of the vector 
\begin_inset Formula $x$
\end_inset

.
 Other distance metrics\InsetSpace ~

\begin_inset LatexCommand \cite[Chapter 10]{pattern-classification}

\end_inset

, such as scatter metrics, can be used instead of the distance metric mentioned
 above.
 Each iteration of the 
\begin_inset Formula $k$
\end_inset

-means algorithms recomputes the means and reclassifies the samples.
 The algorithm terminates when it detects no change in the means.
 See 
\begin_inset LatexCommand \ref{fig:clusters}

\end_inset

 for an illustration.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Standard
\begin_inset Graphics
	filename clusters.png
	lyxscale 5
	scale 30
	rotateAngle 270

\end_inset


\end_layout

\begin_layout Caption
\begin_inset LatexCommand \label{fig:clusters}

\end_inset

Thirteen data points after clustering.
 The small dots are cluster means.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Standard
Present K-means pictures
\end_layout

\begin_layout Standard
Present protocol
\end_layout

\begin_layout Standard
Use pictures from ESORICS talk.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Greyedout
status open

\begin_layout Standard
NOTE: Expand this section
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Standard
\begin_inset LatexCommand \bibtex[plain]{somesh}

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
