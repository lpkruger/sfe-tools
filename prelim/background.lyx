#LyX 1.4.4 created this file. For more info see http://www.lyx.org/
\lyxformat 245
\begin_document
\begin_header
\textclass article
\language english
\inputencoding auto
\fontscheme default
\graphics default
\paperfontsize default
\papersize default
\use_geometry false
\use_amsmath 1
\cite_engine basic
\use_bibtopic false
\paperorientation portrait
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\end_header

\begin_body

\begin_layout Section
Background
\end_layout

\begin_layout Subsection
Primitives
\end_layout

\begin_layout Subsubsection
Oblivious Transfer
\end_layout

\begin_layout Standard
Oblivious transfer is a protocol originally proposed by Rabin 
\begin_inset LatexCommand \cite{Rabin81}

\end_inset

.
 Informally, a 1-out-of-n oblivious transfer, denoted as 
\begin_inset Formula $OT_{n}^{1}$
\end_inset

, is a protocol between two parties, the Chooser and the Sender.
 The Sender's inputs into the protocol are n values 
\begin_inset Formula $v_{1},...,v_{n}$
\end_inset

.
 The Chooser's input is an index i such that 
\begin_inset Formula $1\le i\le n$
\end_inset

.
 As a result of the protocol, the Chooser receives 
\begin_inset Formula $v_{i}$
\end_inset

, but does not learn anything about the rest of the Sender's values.
 The Sender learns nothing.
 The most efficient OT algorithm to date is described in 
\begin_inset LatexCommand \cite{Noar-Pinkas:2001}

\end_inset

.
\end_layout

\begin_layout Subsubsection
Homomorphic Encryption
\end_layout

\begin_layout Standard
Homomorphic Encryption is a class of public key encryption algorithms that
 satisfies the homomorphism property: 
\begin_inset Formula $E(a+b)=E(a)\oplus E(b)$
\end_inset

 where 
\begin_inset Formula $\oplus$
\end_inset

 is an efficient and publically computable operator.
\end_layout

\begin_layout Standard
For general purpose cryptography, the homomorphism property are considered
 undesirable because it can make cryptanalysis easier.
 However, it has been found that homomorphic encryption can lead to efficient
 secure protocols for evaluating certain functions.
 It has found particular application in secure voting protocols.
\end_layout

\begin_layout Standard
Additively homomorphic encryption.
 Let 
\begin_inset Formula $(G,E,D,M)$
\end_inset

 be a public-key encryption scheme, where 
\begin_inset Formula $G$
\end_inset

 is the key generation function, 
\begin_inset Formula $E$
\end_inset

 and 
\begin_inset Formula $D$
\end_inset

 are the encryption and decryption functions, and 
\begin_inset Formula $M$
\end_inset

 is the message space respectively.
 We will assume that:
\end_layout

\begin_layout Itemize
The encryption scheme is semantically secure 
\begin_inset LatexCommand \cite{Goldwasser:Micali}

\end_inset

.
 Informally, this means that the ciphertext leaks no useful information
 about the plaintext even after the adversary has previously observed many
 plaintext-ciphertext pairs on plaintexts of his choice.
\end_layout

\begin_layout Itemize
There exists a computable function 
\begin_inset Formula $g$
\end_inset

 such that for all 
\begin_inset Formula $m\in M$
\end_inset

 and 
\begin_inset Formula $\alpha\in M$
\end_inset

, 
\begin_inset Formula $m_{1}\in E(m)$
\end_inset

 implies that 
\begin_inset Formula $g(m_{1},\alpha)\in E(m)$
\end_inset

.
 With any semantically secure encryption scheme, encrypting the same message
 twice will yield different ciphertexts, so 
\begin_inset Formula $E(m)$
\end_inset

 denotes the set of ciphertexts that can be obtained by encrypting 
\begin_inset Formula $m$
\end_inset

.
 Naturally, if 
\begin_inset Formula $m_{1}\neq m_{2}$
\end_inset

, then 
\begin_inset Formula $E(m_{1})\cap E(m_{2})=\emptyset$
\end_inset


\end_layout

\begin_layout Itemize
There exists a computable function 
\begin_inset Formula $f$
\end_inset

 such that for all messages 
\begin_inset Formula $m_{1}$
\end_inset

 and 
\begin_inset Formula $m_{2}$
\end_inset

, the following property holds:
\newline

\begin_inset Formula $f\left(E(m_{1}),E(m_{2})\right)=E(m_{1}+m_{2})$
\end_inset


\end_layout

\begin_layout Standard
There are several encryption scheme that satisfy these properties, of which
 Paillier's encryption scheme, based on composite residue classes, is the
 most widely used 
\begin_inset LatexCommand \cite{Paillier99}

\end_inset

.
 In the Paillier cryptosystem, the message space is 
\begin_inset Formula $m<n$
\end_inset

, where 
\begin_inset Formula $n=pq$
\end_inset

 for 
\begin_inset Formula $p$
\end_inset

 and 
\begin_inset Formula $q$
\end_inset

 prime.
 The ciphertext space is 
\begin_inset Formula $E(m)<n^{2}$
\end_inset

.
 Let 
\begin_inset Formula $g<n^{2}$
\end_inset

 such that 
\begin_inset Formula $g$
\end_inset

 has order 
\begin_inset Formula $n\alpha$
\end_inset

.
 Using the public key 
\begin_inset Formula $(g,n)$
\end_inset

, the encryption function 
\begin_inset Formula $E(m)=g^{m}r^{n}\left(\mbox{mod }n^{2}\right)$
\end_inset

, for a random 
\begin_inset Formula $r<n$
\end_inset

.
 Using the private key 
\begin_inset Formula $\lambda=\mbox{lcm}(p-1,q-1)$
\end_inset

, the decryption function for ciphertext 
\begin_inset Formula $c$
\end_inset

 is 
\begin_inset Formula $m=\frac{L\left(c^{\lambda}\mbox{ mod }n^{2}\right)}{L\left(g^{\lambda}\mbox{ mod }n^{2}\right)}\mbox{ mod }n$
\end_inset

 where 
\begin_inset Formula $L(u)=\frac{u-1}{n}$
\end_inset

 is a well defined function for 
\begin_inset Formula $u\equiv1\;(\mbox{mod }n)$
\end_inset

.
 Further details can be found in 
\begin_inset LatexCommand \cite{Paillier99}

\end_inset

.
\end_layout

\begin_layout Subsection
Secure Function Evaluation
\end_layout

\begin_layout Standard
One of the fundamental cryptographic primitives for designing privacy-preserving
 protocols is 
\shape italic
secure function evaluation (SFE)
\shape default
.
 A protocol for SFE enables two parties 
\begin_inset Formula $A$
\end_inset

 and 
\begin_inset Formula $B$
\end_inset

 with inputs 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

 respectively to jointly compute a function 
\begin_inset Formula $f(x,y)$
\end_inset

 while preserving the privacy of the two parties' respective inputs.
 At the end of the protocol, party 
\begin_inset Formula $A$
\end_inset

 only knows its input 
\begin_inset Formula $x$
\end_inset

 and the value of the function 
\begin_inset Formula $f(x,y)$
\end_inset

, and a similar condition holds for 
\begin_inset Formula $B$
\end_inset

.
 It was proved by Yao 
\begin_inset LatexCommand \cite{Yao:86}

\end_inset

 and Goldreich, Micali, and Wigderson 
\begin_inset LatexCommand \cite{GMW87}

\end_inset

 that for a polynomially computable function 
\begin_inset Formula $f$
\end_inset

, there exists protocols for securely evaluating 
\begin_inset Formula $f$
\end_inset

 that executes in polynomial time.
 Both proofs are constructive, and provide a method for transforming a boolean
 circuit description of the function 
\begin_inset Formula $f$
\end_inset

 into a protocol for secure evaluation.
 These protocols are summarized here.
\end_layout

\begin_layout Subsubsection
Yao '86
\end_layout

\begin_layout Standard
Consider any Boolean circuit 
\begin_inset Formula $C$
\end_inset

, and two parties, Alice and Bob, who wish to evaluate 
\begin_inset Formula $C$
\end_inset

 on their respective inputs 
\begin_inset Formula $x$
\end_inset

 and 
\begin_inset Formula $y$
\end_inset

.
 In Yao's 
\begin_inset Quotes eld
\end_inset

garbled circuits
\begin_inset Quotes erd
\end_inset

 method, originally proposed in [23], Alice securely transforms the circuit
 so that Bob can evaluate it obliviously, i.e., without learning Alice's inputs
 into the circuit or the values on any internal circuit wire except the
 output wires.
 Alice does this by generating two random keys 
\begin_inset Formula $k_{i,0}$
\end_inset

 and 
\begin_inset Formula $k_{i,1}$
\end_inset

 for each circuit wire 
\begin_inset Formula $i$
\end_inset

, one representing 
\begin_inset Formula $0$
\end_inset

 on that wire, the other representing 
\begin_inset Formula $1$
\end_inset

.
 For all wires in the circuit except input wires, the truth table for the
 corresponding boolean gate is encrypted.
 If 
\begin_inset Formula $g(x,y)$
\end_inset

 is a gate with input wires 
\begin_inset Formula $j$
\end_inset

 and 
\begin_inset Formula $l$
\end_inset

, and output wire 
\begin_inset Formula $i$
\end_inset

, then the truth table value for 
\begin_inset Formula $g(x,y)$
\end_inset

 is encoded as 
\begin_inset Formula $E_{k_{j,x}}\left(E_{k_{l,y}}\left(k_{g(x,y)}\right)\right)$
\end_inset

.
 The four encrypted values 
\begin_inset Formula $g(0,0)$
\end_inset

, 
\begin_inset Formula $g(0,1)$
\end_inset

, 
\begin_inset Formula $g(1,0)$
\end_inset

, and 
\begin_inset Formula $g(1,1)$
\end_inset

 fully specify the gate 
\begin_inset Formula $g$
\end_inset

.
 The keys encoding Alice's own inputs into the circuit she simply sends
 to Bob.
 The keys encoding Bob's inputs are transferred to Bob via the 
\begin_inset Formula $OT_{2}^{1}$
\end_inset

 protocol.
 For each of Bob's input wires, where Bob acts as the chooser using his
 circuit input bit as his input into 
\begin_inset Formula $OT_{2}^{1}$
\end_inset

 , and Alice acts as the sender with the two wire keys for that wire as
 her inputs into 
\begin_inset Formula $OT_{2}^{1}$
\end_inset

 .
 Alice produces the 
\begin_inset Quotes eld
\end_inset

garbled
\begin_inset Quotes erd
\end_inset

 truth table for each circuit gate in such a way that Bob, if he knows the
 wire keys encoding the values on the gate input wires, can decrypt exactly
 one row of the garbled truth table and obtain the key encoding the value
 of the output wire.
 Yao's protocol maintains the invariant that for every circuit wire, Bob
 learns exactly one wire key.
 Because wire keys are random and the mapping from wire keys to values is
 not known to Bob (except for the wire keys corresponding to his own inputs),
 this does not leak any information about actual wire values.
 The circuit can thus be evaluated obliviously.
 A complete description of Yao's method and security proofs can be found
 in 
\begin_inset LatexCommand \cite{Goldreich:vol2}

\end_inset

.
\end_layout

\begin_layout Subsubsection
Goldreich, Micali, and Wigderson '87
\end_layout

\begin_layout Standard
\begin_inset LatexCommand \cite{GMW87}

\end_inset

 presents a protocol for securely evaluating circuits known as 
\emph on
secure computation with shares
\emph default
 (SCWS).
 This protocol maintains the invariant that, for every circuit wire 
\begin_inset Formula $w$
\end_inset

, Alice learns a random value 
\begin_inset Formula $s$
\end_inset

 and Bob learns 
\begin_inset Formula $b_{w}\oplus s$
\end_inset

, where 
\begin_inset Formula $b_{w}$
\end_inset

 is the bit value of the wire.
 Therefore, Alice's and Bob's shares add up to 
\begin_inset Formula $b_{w}$
\end_inset

, but because the shares are random, neither party knows the actual wire
 value.
 For each output wire of the circuit, Alice and Bob combine their shares
 to reconstruct the circuit output.
 Suppose 
\begin_inset Formula $g(x,y)$
\end_inset

 is a gate, and 
\family roman
\series medium
\shape up
\size normal
\emph off
\bar no
\noun off
\color none

\begin_inset Formula $x_{a}\oplus x_{b}=x$
\end_inset

 and 
\family default
\series default
\shape default
\size default
\emph default
\bar default
\noun default

\begin_inset Formula $y_{a}\oplus y_{b}=y$
\end_inset

.
 To evaluate the gate, Alice selects a random bit 
\begin_inset Formula $z_{a}$
\end_inset

 and constructs a quadruple 
\begin_inset Formula $\left(g(x_{a},y_{a})\oplus z_{a},\, g(x_{a},1-y_{a})\oplus z_{a},\, g(1-x_{a},y_{a})\oplus z_{a},\, g(1-x_{a},1-y_{a})\oplus z_{a}\right)$
\end_inset

.
 The value in this quadruple with index 
\begin_inset Formula $2x_{b}+y_{b}$
\end_inset

 will be the value 
\begin_inset Formula $z_{b}=g(x,y)\oplus z_{a}$
\end_inset

.
 Using an 
\begin_inset Formula $OT_{4}^{1}$
\end_inset

 protocol, Bob can receive the value 
\begin_inset Formula $z_{b}$
\end_inset

 obliviously.
 By evaluating all gates in the circuits using this method, the function
 is securely evaluated.
 Further details and security proofs are presented in 
\begin_inset LatexCommand \cite{Goldreich:vol2}

\end_inset

.
\end_layout

\begin_layout Subsection
Implementations
\end_layout

\begin_layout Standard
In recent years, there have been implementations of SFE undertaken by researcher
s to design secure multiparty protocols.
 In the past, SFE was considered a theoretical topic too expensive for practical
 use, but the convergence of ubiquitous communication using the Internet,
 more efficient cryptographic primitives, and the exponentially increasing
 available of processing power and network bandwidth are making SFE an area
 of increasingly significant practical value.
\end_layout

\begin_layout Subsubsection
Fairplay
\end_layout

\begin_layout Standard
Fairplay 
\begin_inset LatexCommand \cite{Fairplay}

\end_inset

 is an example of an SFE implementation designed to enable wider application
 of SFE.
 Fairplay is the first system, designed to be practical, that attempts to
 make SFE using Yao's protocol available to a wider audience.
 It consists of a compiler that takes as input a function 
\begin_inset Formula $f$
\end_inset

 defined using a procedural language called 
\emph on
Secure Function Description Language
\emph default
 (SFDL), and outputs a boolean circuit to evaluate 
\begin_inset Formula $f$
\end_inset

 using a description language called 
\emph on
Secure Hardware Description Language
\emph default
 (SHDL).
 Fairplay also includes an implementation of the two party Yao protocol
 which securely evaluates an SHDL function.
 The paper provides the first empirical measurements from an implementation
 of the Yao protocol.
\end_layout

\begin_layout Subsubsection
Application specific
\end_layout

\begin_layout Standard
Fairplay showed that the classic protocol for SFE is still quite expensive
 for all but the simplest circuits.
 There has been much research effort in designing more efficient privacy-preserv
ing protocols for many problems of interest.
 In 
\begin_inset LatexCommand \cite{Reiter:CCS:2003}

\end_inset

, a compiler was implemented for generating secure two-party protocols for
 a restricted class of functions built from modular arithmetic.
 The particular design was motivated by the desire to build efficient secure
 protocols such as signature schemes and threshold cryptography.
 Secure protocols have been implemented for many problems such as auctions
 
\begin_inset LatexCommand \cite{NPS99}

\end_inset

, set intersection 
\begin_inset LatexCommand \cite{FNP04}

\end_inset

, and conducting surveys 
\begin_inset LatexCommand \cite{FNP04}

\end_inset

.
 A particularly important application of secure computation is discussed
 in the next section.
\end_layout

\begin_layout Subsection
Privacy Preserving Data Mining 
\end_layout

\begin_layout Standard
Initial focus in this area was on construction of decision trees from distribute
d data sets 
\begin_inset LatexCommand \cite{Agrawal-Srikant,Lindell-Pinkas}

\end_inset

.
 There is also a significant body of research on privacy-preserving mining
 of association rules 
\begin_inset LatexCommand \cite{Gehrke:2002,RizviHarista,VaidyaClifton:2002}

\end_inset

.
 In general, there are two approaches for designing privacy-preserving data
 mining algorithms.
 The first approach is to use transformations to perturb the data set before
 the algorithm is applied, by replacing sensitive data with random unique
 identifiers.
 This approach for designing privacy-preserving algorithms is taken by several
 researchers 
\begin_inset LatexCommand \cite{Klusch,MeruguGhosh,Oliveira}

\end_inset

.
 However, this approach suffers from a lack of formal guarentees of security,
 and has been shown to be vulnerable to data correlation attacks 
\begin_inset LatexCommand \cite{Malin04}

\end_inset

.
 Secure multiparty computation is the basis of the other approach.
 A survey of such techniques iss presented in 
\begin_inset LatexCommand \cite{PinkasCryptoPPDM02}

\end_inset

.
\end_layout

\begin_layout Subsection
Threat Models
\end_layout

\begin_layout Standard
In the 
\begin_inset Quotes eld
\end_inset

semi-honest
\begin_inset Quotes erd
\end_inset

 threat model, also known as 
\begin_inset Quotes eld
\end_inset

honest but curious
\begin_inset Quotes erd
\end_inset

, or 
\begin_inset Quotes eld
\end_inset

passive
\begin_inset Quotes erd
\end_inset

, a party to the computation is assumed to behave correctly and follow the
 protocol as proscribed.
 However, the party also runs additional probabilistic polynomially bounded
 computation on the side in order to learn information to which he is not
 entitled.
 A security proof using the semi-honest threat model implies that the protocol
 as designed does not 
\begin_inset Quotes eld
\end_inset

leak
\begin_inset Quotes erd
\end_inset

 information.
 For reasons that will be discussed shortly, security proofs in the semi-honest
 model are useful despite that fact that it is not a natural model of adversaria
l behavior.
\end_layout

\begin_layout Standard
In the 
\begin_inset Quotes eld
\end_inset

malicious
\begin_inset Quotes erd
\end_inset

 threat model, a badly behaving party is free to use any available methods
 to thwart the computation, including sending false or inconsistent messages
 at any step of the protocol.
 The malicious model is a stronger threat model, and naturally characterizes
 the malicious behavior that a secure protocol would need to protect against.
 These threat models were presented in 
\begin_inset LatexCommand \cite{GMW87}

\end_inset

, along with a proof that it is possible to transform any protocol that
 is secure in the semi-honest model into an equivalent protocol that is
 secure in the malicious model.
 
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Standard
\begin_inset LatexCommand \bibtex[plain]{privacy,somesh}

\end_inset


\end_layout

\end_inset


\end_layout

\end_body
\end_document
