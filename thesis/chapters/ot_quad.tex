
\chapter{Oblivious Transfer with Modular Square Roots}\label{sec:OT-SquareRoots}
\label{chapter:otquad}

A new $OT_{2}^{1}$ protocol is presented, using the square root function
in modular multiplicative groups as a trapdoor function. Here, I present
a informal sketch of correctness, security, and efficiency. I propose
to complete the proofs and perform a thorough experimental evaluation
of its performance with respect to other oblivious transfer protocols.


\section{Protocol}
\begin{enumerate}
\item The sender chooses large random prime numbers $p$ and $q$ such that
$p\equiv q\equiv3\;(\mbox{mod }4)$ and calculates $n=pq$. $n$ is
sent to the chooser. This is a one time setup step that need not be
repeated for subsequent uses of the protocol.
\item The chooser uniformly chooses a random value $x\in S\subset Z_{n}^{*}$
where $S=\{z\in Z_{n}^{*}:$~$z\le\frac{n-1}{2}\mbox{ and }$ $\left(\frac{z}{n}\right)=-1$
if $s=1$ otherwise $\left(\frac{z}{n}\right)=+1\}$. The chooser
computes $y\equiv x^{2}(\mbox{mod }n)$ and sends $y$ to the sender.
$\left(\frac{x}{n}\right)$ denotes the Jacobi symbol of $x$ and
$n$.
\item The sender calculates the square roots $a^{2}\equiv b^{2}\equiv y\;(mod\, n)$
such that $\left(\frac{a}{n}\right)=-1$ and $\left(\frac{b}{n}\right)=+1$
and $a,b\le\frac{n-1}{2}$
\item The sender encrypts $E_{a}(m_{1})$ and $E_{b}(m_{2})$ and sends
them to the chooser.
\item The chooser computes $D_{x}(E_{x}(m_{s}))$ to decrypt the output.
\end{enumerate}

\section{Correctness}

$\left(\frac{x}{n}\right)=-1$ for half the elements $x\in Z_{n}^{*}$
. $\left(\frac{x}{n}\right)=+1$ for the other half. Thus the chooser
can always successfully perform step 2.

If $a^{2}\equiv b^{2}\;(mod\; n)$ and $a\neq\pm b\;(mod\; n)$ then
$\left(\frac{a}{n}\right)=-\left(\frac{b}{n}\right)$.%
\footnote{This follows when $p\equiv q\equiv3\ (\mbox{mod 4})$ from the properties
of the Jacobi symbol and the Chinese Remainder Theorem.%
} Furthermore, the set $\{a,b,n-a,n-b\}$is the complete set of square
roots of $y$. If $a>\frac{n-1}{2}$ then $a$ and $n-a$ can be swapped,
and similarly for $b$. Thus, the sender can always successfully complete
step 3. It is guaranteed that either $a=x$ or $b=x$ so the chooser
will successfully learn $m_{s}$ as intended.


\section{Security}

Finding all square roots of any quadratic residue in $Z_{n}^{*}$
can be reduced to factoring $n$. This is because given two principal
square roots $a^{2}\equiv b^{2}$, $a\neq-b$, then $(a-b)(a+b)\equiv0$
so $(a-b)(a+b)=kpq$ Under the standard complexity assumption that
factoring $n$ is infeasable, then the chooser can not efficiently
learn the other square root of $x^{2}$, which is the encryption key
of $E(m_{3-s})$ and the sender's privacy is preserved. 

The chooser's privacy is preserved because the sender does not know
whether the chooser calculated $y=a^{2}$ or $y=b^{2}$. From the
sender's perspective, the chooser has chosen $x$ from a uniform random
distribution $1\le x\le\frac{n-1}{2}$, so there is no information
that can be gained. The chooser therefore enjoys unconditional security
even without making assumptions about the senders computation power.


\section{Efficiency}

In the setup phase, the sender needs to calculate $n=pq$ once and
send the value of $n$ to the chooser. This requires one multiplication
and transmission of $k=\log n$ bits. The same value of $n$ can be
reused for subsequent or batched OTs without loss of security. $k$
must be large enough to prevent efficient factoring of $n$.

From then on, each OT requires the following: 
\begin{enumerate}
\item Computation of Jacobi symbols $\left(\frac{x}{n}\right)$ by the chooser.
If the chooser uses random trials to find an appropriate $x$, then
the expected number of trials is $2$. Computing Jacobi symbols can
be performed in $O(k\log x)\le O(k^{2})$ steps \cite{1996-bach-book}. 
\item There is a potential optimization of step 1. The chooser can pre-compute
a single number $\alpha$ where $\left(\frac{\alpha}{n}\right)=-1$.
From then on, the chooser can choose any random $\beta$ and have
$\left(\frac{\beta^{2}}{n}\right)=+1$ and $\left(\frac{\alpha\beta^{2}}{n}\right)=-1$.
This optimization as presented is insecure, because it breaks statistical
indistinguishability for the chooser~%
\footnote{The optimization will never produce a non-QR with $+1$ Jacobi symbol%
}. However, I speculate that there may exist a variation which avoids
this flaw and thereby reduces the chooser's overall complexity to
$O(k)$.
\item Transmission of a single $k$ bit number from chooser to sender
\item Computation by the sender of square roots of $y$. This can be performed
using a randomized algorithm in expected time $O(k\ \log\, p^{2})\le O(k^{3})$
steps for $p>q$ \cite{1996-bach-book}. 
\item Encryption and transmission by the sender of the two messages. If
the sender does not need to hide the length of the unreceived message,
then this requires no more bandwidth than the actual size of the messages,
which is $O(\log m)$
\item Decryption by the receiver of one of the messages, which is $O(\log m)$.
\end{enumerate}
If the sender and chooser wish to execute the protocol multiple times,
the chooser can simply send a vector $[y_{1},\cdots,y_{j}]$ and the
chooser will respond with a vector of tuples $[(E_{a_{1}}(m_{1_{1}}),(E_{b_{1}}(m_{1_{2}}))\cdots(E_{a_{j}}(m_{j_{1}}),(E_{b_{j}}(m_{j{}_{2}}))]$
where $j$ is the number of messages to be sent obliviously. Each
$x_{i}$ is an independent random variable so the security is equivalent
to the single message case. Thus, unlimited bits can be transferred
with a single network round-trip.


\section{Comparison with Naor-Pinkas\label{sub:Comparison-with-Naor-Pinkas}}

In the Naor-Pinkas protocol \cite{Noar-Pinkas:2001}, the computational
requirement for each party is $O((\log n)(\log\log n))$ for both
parties, where $n$ is the size of a group sufficiently large such
that calculating discrete logarithms is infeasible. The communication
consists of a message of size $\log n$ from sender to chooser, a
message of size $\log n$ from chooser to sender, and two messages
of size $\log m+\log n$ from sender to chooser, where $\log m$ is
the size of the chooser's outputs. The protocol presented here cuts
the final messages to $\log m$, which effectively reduces the bandwidth
with a tradeoff in computation time. My experimentation with running
SFE algorithms using fast modern CPUs indicates that this tradeoff
may be worthwhile. I plan to make empirical measurements with implementations
of the to comparitively measure the actual performance.


\section{Extensions}

It may be possible to extend the construction to cover the more general
$OT_{k}^{1}$. I have not investigated this yet, but one idea is to
let $n=\prod_{i=1}^{k}p_{i}$ where each $p_{i}$ is a large prime
number. In $Z_{n}^{*}$, each quadratic residue will have $2^{k}$
square roots consisting of $2^{k-1}$ pairs $(x,n-x)$

%
\begin{comment}
\bibliographystyle{plain}
\bibliography{crypto,privacy,somesh}

\end{comment}
{}


